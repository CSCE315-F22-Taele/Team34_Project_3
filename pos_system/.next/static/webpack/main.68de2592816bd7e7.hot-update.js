"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _classCallCheck = (__webpack_require__(/*! @swc/helpers/lib/_class_call_check.js */ \"./node_modules/@swc/helpers/lib/_class_call_check.js\")[\"default\"]);\nvar _createClass = (__webpack_require__(/*! @swc/helpers/lib/_create_class.js */ \"./node_modules/@swc/helpers/lib/_create_class.js\")[\"default\"]);\nvar _inherits = (__webpack_require__(/*! @swc/helpers/lib/_inherits.js */ \"./node_modules/@swc/helpers/lib/_inherits.js\")[\"default\"]);\nvar _interopRequireWildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\nvar _createSuper = (__webpack_require__(/*! @swc/helpers/lib/_create_super.js */ \"./node_modules/@swc/helpers/lib/_create_super.js\")[\"default\"]);\nvar _tsGenerator = (__webpack_require__(/*! @swc/helpers/lib/_ts_generator.js */ \"./node_modules/@swc/helpers/lib/_ts_generator.js\")[\"default\"]);\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.initialize = initialize;\nexports.hydrate = hydrate;\nexports.emitter = exports.router = exports.version = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _mitt = _interop_require_default(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _runtimeConfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nvar _headManager = _interop_require_default(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nvar _pageLoader = _interop_require_default(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nvar _performanceRelayer = _interop_require_default(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nvar _routeAnnouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nvar _isError = __webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\");\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nvar _removeBasePath = __webpack_require__(/*! ./remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _hasBasePath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar ReactDOM =  true ? __webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\") : 0;\nvar version = \"12.3.2\";\nexports.version = version;\nvar router;\nexports.router = router;\nvar emitter = (0, _mitt).default();\nexports.emitter = emitter;\nvar looseToArray = function(input) {\n    return [].slice.call(input);\n};\nvar initialData;\nvar defaultLocale = undefined;\nvar asPath;\nvar pageLoader;\nvar appElement;\nvar headManager;\nvar initialMatchesMiddleware = false;\nvar lastAppProps;\nvar lastRenderReject;\nvar webpackHMR;\nvar CachedApp, onPerfEntry;\nvar CachedComponent;\nself.__next_require__ = __webpack_require__;\nvar Container = /*#__PURE__*/ function(_Component) {\n    \"use strict\";\n    _inherits(Container, _Component);\n    var _super = _createSuper(Container);\n    function Container() {\n        _classCallCheck(this, Container);\n        return _super.apply(this, arguments);\n    }\n    _createClass(Container, [\n        {\n            key: \"componentDidCatch\",\n            value: function componentDidCatch(componentErr, info) {\n                this.props.fn(componentErr, info);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this.scrollToHash();\n                // We need to replace the router state if:\n                // - the page was (auto) exported and has a query string or search (hash)\n                // - it was auto exported and is a dynamic route (to provide params)\n                // - if it is a client-side skeleton (fallback render)\n                // - if middleware matches the current page (may have rewrite params)\n                // - if rewrites in next.config.js match (may have rewrite params)\n                if (router.isSsr && // We don't update for 404 requests as this can modify\n                // the asPath unexpectedly e.g. adding basePath when\n                // it wasn't originally present\n                initialData.page !== \"/404\" && initialData.page !== \"/_error\" && (initialData.isFallback || initialData.nextExport && ((0, _isDynamic).isDynamicRoute(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n                    // update query on mount for exported pages\n                    router.replace(router.pathname + \"?\" + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n                        // @ts-ignore\n                        // WARNING: `_h` is an internal option for handing Next.js\n                        // client-side hydration. Your app should _never_ use this property.\n                        // It may change at any time without notice.\n                        _h: 1,\n                        // Fallback pages must trigger the data fetch, so the transition is\n                        // not shallow.\n                        // Other pages (strictly updating query) happens shallowly, as data\n                        // requirements would already be present.\n                        shallow: !initialData.isFallback && !initialMatchesMiddleware\n                    }).catch(function(err) {\n                        if (!err.cancelled) throw err;\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                this.scrollToHash();\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash() {\n                var hash = location.hash;\n                hash = hash && hash.substring(1);\n                if (!hash) return;\n                var el = document.getElementById(hash);\n                if (!el) return;\n                // If we call scrollIntoView() in here without a setTimeout\n                // it won't scroll properly.\n                setTimeout(function() {\n                    return el.scrollIntoView();\n                }, 0);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (false) {} else {\n                    var ReactDevOverlay = (__webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\").ReactDevOverlay);\n                    return /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children);\n                }\n            }\n        }\n    ]);\n    return Container;\n}(_react.default.Component);\nfunction initialize() {\n    return _initialize.apply(this, arguments);\n}\nfunction _initialize() {\n    _initialize = _async_to_generator(function() {\n        var opts, prefix, normalizeLocalePath, detectDomainLocale, parseRelativeUrl, formatUrl, parsedAs, localePathResult, detectedDomain, initScriptLoader, register;\n        var _arguments = arguments;\n        return _tsGenerator(this, function(_state) {\n            opts = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : {};\n            // This makes sure this specific lines are removed in production\n            if (true) {\n                webpackHMR = opts.webpackHMR;\n            }\n            initialData = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\n            window.__NEXT_DATA__ = initialData;\n            defaultLocale = initialData.defaultLocale;\n            prefix = initialData.assetPrefix || \"\";\n            // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n            // So, this is how we do it in the client side at runtime\n            __webpack_require__.p = \"\".concat(prefix, \"/_next/\") //eslint-disable-line\n            ;\n            // Initialize next/config with the environment configuration\n            (0, _runtimeConfig).setConfig({\n                serverRuntimeConfig: {},\n                publicRuntimeConfig: initialData.runtimeConfig || {}\n            });\n            asPath = (0, _utils).getURL();\n            // make sure not to attempt stripping basePath for 404s\n            if ((0, _hasBasePath).hasBasePath(asPath)) {\n                asPath = (0, _removeBasePath).removeBasePath(asPath);\n            }\n            if (false) {}\n            if (initialData.scriptLoader) {\n                initScriptLoader = (__webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\").initScriptLoader);\n                initScriptLoader(initialData.scriptLoader);\n            }\n            pageLoader = new _pageLoader.default(initialData.buildId, prefix);\n            register = function(param) {\n                var _param = _slicedToArray(param, 2), r = _param[0], f = _param[1];\n                return pageLoader.routeLoader.onEntrypoint(r, f);\n            };\n            if (window.__NEXT_P) {\n                // Defer page registration for another tick. This will increase the overall\n                // latency in hydrating the page, but reduce the total blocking time.\n                window.__NEXT_P.map(function(p) {\n                    return setTimeout(function() {\n                        return register(p);\n                    }, 0);\n                });\n            }\n            window.__NEXT_P = [];\n            window.__NEXT_P.push = register;\n            headManager = (0, _headManager).default();\n            headManager.getIsSsr = function() {\n                return router.isSsr;\n            };\n            appElement = document.getElementById(\"__next\");\n            return [\n                2,\n                {\n                    assetPrefix: prefix\n                }\n            ];\n        });\n    });\n    return _initialize.apply(this, arguments);\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _react.default.createElement(App, Object.assign({}, appProps));\n}\nfunction AppContainer(param) {\n    var children = param.children;\n    return /*#__PURE__*/ _react.default.createElement(Container, {\n        fn: function(error) {\n            return(// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch(function(err) {\n                return console.error(\"Error rendering page: \", err);\n            }));\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_routerContext.RouterContext.Provider, {\n        value: (0, _router).makePublicRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headManagerContext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_imageConfigContext.ImageConfigContext.Provider, {\n        value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    }, children))));\n}\n_c = AppContainer;\nvar wrapApp = function(App) {\n    return function(wrappedAppProps) {\n        var appProps = _extends({}, wrappedAppProps, {\n            Component: CachedComponent,\n            err: initialData.err,\n            router: router\n        });\n        return /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps));\n    };\n};\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    var App = renderErrorProps.App, err = renderErrorProps.err;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: function() {\n                return null;\n            },\n            props: {},\n            Component: function() {\n                return null;\n            },\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage(\"/_error\").then(function(param) {\n        var ErrorComponent = param.page, styleSheets = param.styleSheets;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(function() {\n            return /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\"));\n        }).then(function(errorModule) {\n            return Promise.resolve().then(function() {\n                return /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../pages/_app */ \"./node_modules/next/dist/pages/_app.js\"));\n            }).then(function(appModule) {\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then(function(m) {\n            return {\n                ErrorComponent: m.default,\n                styleSheets: []\n            };\n        }) : {\n            ErrorComponent: ErrorComponent,\n            styleSheets: styleSheets\n        };\n    }).then(function(param) {\n        var ErrorComponent = param.ErrorComponent, styleSheets = param.styleSheets;\n        var ref;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        var AppTree = wrapApp(App);\n        var appCtx = {\n            Component: ErrorComponent,\n            AppTree: AppTree,\n            router: router,\n            ctx: {\n                err: err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath: asPath,\n                AppTree: AppTree\n            }\n        };\n        return Promise.resolve(((ref = renderErrorProps.props) == null ? void 0 : ref.err) ? renderErrorProps.props : (0, _utils).loadGetInitialProps(App, appCtx)).then(function(initProps) {\n            return(// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender(_extends({}, renderErrorProps, {\n                err: err,\n                Component: ErrorComponent,\n                styleSheets: styleSheets,\n                props: initProps\n            })));\n        });\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    var callback = param.callback;\n    _s();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(function() {\n        return callback();\n    }, [\n        callback\n    ]);\n    return null;\n}\n_s(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nvar reactRoot = null;\n// On initial render a hydrate should always happen\nvar shouldHydrate = true;\nfunction clearMarks() {\n    [\n        \"beforeRender\",\n        \"afterHydrate\",\n        \"afterRender\",\n        \"routeChange\"\n    ].forEach(function(mark) {\n        return performance.clearMarks(mark);\n    });\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterHydrate\") // mark end of hydration\n    ;\n    performance.measure(\"Next.js-before-hydration\", \"navigationStart\", \"beforeRender\");\n    performance.measure(\"Next.js-hydration\", \"beforeRender\", \"afterHydrate\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-hydration\").forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterRender\") // mark end of render\n    ;\n    var navStartEntries = performance.getEntriesByName(\"routeChange\", \"mark\");\n    if (!navStartEntries.length) return;\n    performance.measure(\"Next.js-route-change-to-render\", navStartEntries[0].name, \"beforeRender\");\n    performance.measure(\"Next.js-render\", \"beforeRender\", \"afterRender\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-render\").forEach(onPerfEntry);\n        performance.getEntriesByName(\"Next.js-route-change-to-render\").forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        \"Next.js-route-change-to-render\",\n        \"Next.js-render\"\n    ].forEach(function(measure) {\n        return performance.clearMeasures(measure);\n    });\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(\"beforeRender\");\n    }\n    var reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (true) {\n        if (!reactRoot) {\n            // Unlike with createRoot, you don't need a separate root.render() call here\n            reactRoot = ReactDOM.hydrateRoot(domEl, reactEl);\n            // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n            shouldHydrate = false;\n        } else {\n            var startTransition = _react.default.startTransition;\n            startTransition(function() {\n                reactRoot.render(reactEl);\n            });\n        }\n    } else {}\n}\nfunction Root(param) {\n    var callbacks = param.callbacks, children = param.children;\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(function() {\n        return callbacks.forEach(function(callback) {\n            return callback();\n        });\n    }, [\n        callbacks\n    ]);\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(function() {\n        (0, _performanceRelayer).default(onPerfEntry);\n    }, []);\n    if (false) {}\n    return children;\n}\n_s1(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c2 = Root;\nfunction doRender(input) {\n    var onStart = // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== \"production\") {\n            return false;\n        }\n        var currentStyleTags = looseToArray(document.querySelectorAll(\"style[data-n-href]\"));\n        var currentHrefs = new Set(currentStyleTags.map(function(tag) {\n            return tag.getAttribute(\"data-n-href\");\n        }));\n        var noscript = document.querySelector(\"noscript[data-n-css]\");\n        var nonce = noscript == null ? void 0 : noscript.getAttribute(\"data-n-css\");\n        styleSheets.forEach(function(param) {\n            var href = param.href, text = param.text;\n            if (!currentHrefs.has(href)) {\n                var styleTag = document.createElement(\"style\");\n                styleTag.setAttribute(\"data-n-href\", href);\n                styleTag.setAttribute(\"media\", \"x\");\n                if (nonce) {\n                    styleTag.setAttribute(\"nonce\", nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    };\n    var onHeadCommit = function onHeadCommit() {\n        if (// unless we're in production:\n        false) { var referenceNode, idx, currentHrefs, currentStyleTags, desiredHrefs; }\n        if (input.scroll) {\n            var htmlElement = document.documentElement;\n            var existing = htmlElement.style.scrollBehavior;\n            htmlElement.style.scrollBehavior = \"auto\";\n            window.scrollTo(input.scroll.x, input.scroll.y);\n            htmlElement.style.scrollBehavior = existing;\n        }\n    };\n    var onRootCommit = function onRootCommit() {\n        resolvePromise();\n    };\n    var App = input.App, Component = input.Component, props = input.props, err = input.err;\n    var styleSheets = \"initial\" in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    var appProps = _extends({}, props, {\n        Component: Component,\n        err: err,\n        router: router\n    });\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    var canceled = false;\n    var resolvePromise;\n    var renderPromise = new Promise(function(resolve, reject) {\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = function() {\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = function() {\n            canceled = true;\n            lastRenderReject = null;\n            var error = new Error(\"Cancel rendering route\");\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    onStart();\n    var elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeAnnouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, function(callback) {\n        return /*#__PURE__*/ _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  true ? /*#__PURE__*/ _react.default.createElement(_react.default.StrictMode, null, elem) : 0);\n    });\n    return renderPromise;\n}\nfunction render(renderingProps) {\n    return _render.apply(this, arguments);\n}\nfunction _render() {\n    _render = _async_to_generator(function(renderingProps) {\n        var err, renderErr;\n        return _tsGenerator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (!renderingProps.err) return [\n                        3,\n                        2\n                    ];\n                    return [\n                        4,\n                        renderError(renderingProps)\n                    ];\n                case 1:\n                    _state.sent();\n                    return [\n                        2\n                    ];\n                case 2:\n                    _state.trys.push([\n                        2,\n                        4,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        doRender(renderingProps)\n                    ];\n                case 3:\n                    _state.sent();\n                    return [\n                        3,\n                        6\n                    ];\n                case 4:\n                    err = _state.sent();\n                    renderErr = (0, _isError).getProperError(err);\n                    // bubble up cancelation errors\n                    if (renderErr.cancelled) {\n                        throw renderErr;\n                    }\n                    if (true) {\n                        // Ensure this error is displayed in the overlay in development\n                        setTimeout(function() {\n                            throw renderErr;\n                        });\n                    }\n                    return [\n                        4,\n                        renderError(_extends({}, renderingProps, {\n                            err: renderErr\n                        }))\n                    ];\n                case 5:\n                    _state.sent();\n                    return [\n                        3,\n                        6\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _render.apply(this, arguments);\n}\nfunction hydrate(opts) {\n    return _hydrate.apply(this, arguments);\n}\nfunction _hydrate() {\n    _hydrate = _async_to_generator(function(opts) {\n        var initialErr, appEntrypoint, app, mod, pageEntrypoint, _tmp, isValidElementType, error1, getServerError, renderCtx;\n        return _tsGenerator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    initialErr = initialData.err;\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        6,\n                        ,\n                        7\n                    ]);\n                    return [\n                        4,\n                        pageLoader.routeLoader.whenEntrypoint(\"/_app\")\n                    ];\n                case 2:\n                    appEntrypoint = _state.sent();\n                    if (\"error\" in appEntrypoint) {\n                        throw appEntrypoint.error;\n                    }\n                    app = appEntrypoint.component, mod = appEntrypoint.exports;\n                    CachedApp = app;\n                    if (mod && mod.reportWebVitals) {\n                        onPerfEntry = function(param) {\n                            var id = param.id, name = param.name, startTime = param.startTime, value = param.value, duration = param.duration, entryType = param.entryType, entries = param.entries;\n                            // Combines timestamp with random number for unique ID\n                            var uniqueID = \"\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                            var perfStartEntry;\n                            if (entries && entries.length) {\n                                perfStartEntry = entries[0].startTime;\n                            }\n                            var webVitals = {\n                                id: id || uniqueID,\n                                name: name,\n                                startTime: startTime || perfStartEntry,\n                                value: value == null ? duration : value,\n                                label: entryType === \"mark\" || entryType === \"measure\" ? \"custom\" : \"web-vital\"\n                            };\n                            mod.reportWebVitals(webVitals);\n                        };\n                    }\n                    if (!// error, so we need to skip waiting for the entrypoint.\n                    ( true && initialData.err)) return [\n                        3,\n                        3\n                    ];\n                    _tmp = {\n                        error: initialData.err\n                    };\n                    return [\n                        3,\n                        5\n                    ];\n                case 3:\n                    return [\n                        4,\n                        pageLoader.routeLoader.whenEntrypoint(initialData.page)\n                    ];\n                case 4:\n                    _tmp = _state.sent();\n                    _state.label = 5;\n                case 5:\n                    pageEntrypoint = _tmp;\n                    if (\"error\" in pageEntrypoint) {\n                        throw pageEntrypoint.error;\n                    }\n                    CachedComponent = pageEntrypoint.component;\n                    if (true) {\n                        isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                        if (!isValidElementType(CachedComponent)) {\n                            throw new Error('The default export is not a React Component in page: \"'.concat(initialData.page, '\"'));\n                        }\n                    }\n                    return [\n                        3,\n                        7\n                    ];\n                case 6:\n                    error1 = _state.sent();\n                    // This catches errors like throwing in the top level of a module\n                    initialErr = (0, _isError).getProperError(error1);\n                    return [\n                        3,\n                        7\n                    ];\n                case 7:\n                    if (true) {\n                        getServerError = (__webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\").getServerError);\n                        // Server-side runtime errors need to be re-thrown on the client-side so\n                        // that the overlay is rendered.\n                        if (initialErr) {\n                            if (initialErr === initialData.err) {\n                                setTimeout(function() {\n                                    var error;\n                                    try {\n                                        // Generate a new error object. We `throw` it because some browsers\n                                        // will set the `stack` when thrown, and we want to ensure ours is\n                                        // not overridden when we re-throw it below.\n                                        throw new Error(initialErr.message);\n                                    } catch (e) {\n                                        error = e;\n                                    }\n                                    error.name = initialErr.name;\n                                    error.stack = initialErr.stack;\n                                    throw getServerError(error, initialErr.source);\n                                });\n                            } else {\n                                setTimeout(function() {\n                                    throw initialErr;\n                                });\n                            }\n                        }\n                    }\n                    if (!window.__NEXT_PRELOADREADY) return [\n                        3,\n                        9\n                    ];\n                    return [\n                        4,\n                        window.__NEXT_PRELOADREADY(initialData.dynamicIds)\n                    ];\n                case 8:\n                    _state.sent();\n                    _state.label = 9;\n                case 9:\n                    exports.router = router = (0, _router).createRouter(initialData.page, initialData.query, asPath, {\n                        initialProps: initialData.props,\n                        pageLoader: pageLoader,\n                        App: CachedApp,\n                        Component: CachedComponent,\n                        wrapApp: wrapApp,\n                        err: initialErr,\n                        isFallback: Boolean(initialData.isFallback),\n                        subscription: function(info, App, scroll) {\n                            return render(Object.assign({}, info, {\n                                App: App,\n                                scroll: scroll\n                            }));\n                        },\n                        locale: initialData.locale,\n                        locales: initialData.locales,\n                        defaultLocale: defaultLocale,\n                        domainLocales: initialData.domainLocales,\n                        isPreview: initialData.isPreview\n                    });\n                    return [\n                        4,\n                        router._initialMatchesMiddlewarePromise\n                    ];\n                case 10:\n                    initialMatchesMiddleware = _state.sent();\n                    renderCtx = {\n                        App: CachedApp,\n                        initial: true,\n                        Component: CachedComponent,\n                        props: initialData.props,\n                        err: initialErr\n                    };\n                    if (!(opts == null ? void 0 : opts.beforeRender)) return [\n                        3,\n                        12\n                    ];\n                    return [\n                        4,\n                        opts.beforeRender()\n                    ];\n                case 11:\n                    _state.sent();\n                    _state.label = 12;\n                case 12:\n                    render(renderCtx);\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _hydrate.apply(this, arguments);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csS0FBSyxFQUFFLElBQUk7Q0FDZCxFQUFDLENBQUM7QUFDSEQsa0JBQWtCLEdBQUdFLFVBQVUsQ0FBQztBQUNoQ0YsZUFBZSxHQUFHRyxPQUFPLENBQUM7QUFDMUJILGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDNUQsSUFBSU8sbUJBQW1CLEdBQUdDLHlJQUEwRDtBQUNwRixJQUFJRSxRQUFRLEdBQUdGLG1IQUErQztBQUM5RCxJQUFJRyx3QkFBd0IsR0FBR0gsbUpBQStEO0FBQzlGLElBQUlJLHlCQUF5QixHQUFHSixxSkFBZ0U7QUFDaEdBLG1CQUFPLENBQUMsdUdBQW9DLENBQUMsQ0FBQztBQUM5QyxJQUFJSyxNQUFNLEdBQUdGLHdCQUF3QixDQUFDSCxtQkFBTyxDQUFDLDRDQUFPLENBQUMsQ0FBQztBQUN2RCxJQUFJTSxtQkFBbUIsR0FBR04sbUJBQU8sQ0FBQyx1R0FBb0MsQ0FBQztBQUN2RSxJQUFJTyxLQUFLLEdBQUdKLHdCQUF3QixDQUFDSCxtQkFBTyxDQUFDLHVFQUFvQixDQUFDLENBQUM7QUFDbkUsSUFBSVEsY0FBYyxHQUFHUixtQkFBTyxDQUFDLDJGQUE4QixDQUFDO0FBQzVELElBQUlTLFVBQVUsR0FBR1QsbUJBQU8sQ0FBQyw2R0FBdUMsQ0FBQztBQUNqRSxJQUFJVSxZQUFZLEdBQUdWLG1CQUFPLENBQUMsK0dBQXdDLENBQUM7QUFDcEUsSUFBSVcsY0FBYyxHQUFHWCxtQkFBTyxDQUFDLDJGQUE4QixDQUFDO0FBQzVELElBQUlZLE1BQU0sR0FBR1osbUJBQU8sQ0FBQyx5RUFBcUIsQ0FBQztBQUMzQyxJQUFJYSxPQUFPLEdBQUdiLG1CQUFPLENBQUMsaUVBQVUsQ0FBQztBQUNqQyxJQUFJYyxZQUFZLEdBQUdYLHdCQUF3QixDQUFD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QUVULE9BQU8sQ0FBQyxDQUFDO0lBQ3hDK1MsTUFBTSxDQUFDL1MsT0FBTyxHQUFHQSxPQUFPLENBQUNTLE9BQU8sQ0FBQztBQUNuQyxDQUFDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2luZGV4LmpzPzQ2Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmluaXRpYWxpemUgPSBpbml0aWFsaXplO1xuZXhwb3J0cy5oeWRyYXRlID0gaHlkcmF0ZTtcbmV4cG9ydHMuZW1pdHRlciA9IGV4cG9ydHMucm91dGVyID0gZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xudmFyIF9hc3luY190b19nZW5lcmF0b3IgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG5yZXF1aXJlKFwiLi4vYnVpbGQvcG9seWZpbGxzL3BvbHlmaWxsLW1vZHVsZVwiKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaGVhZE1hbmFnZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHRcIik7XG52YXIgX21pdHQgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvbWl0dFwiKSk7XG52YXIgX3JvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfaXNEeW5hbWljID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWNcIik7XG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xudmFyIF9ydW50aW1lQ29uZmlnID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcnVudGltZS1jb25maWdcIik7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XG52YXIgX3BvcnRhbCA9IHJlcXVpcmUoXCIuL3BvcnRhbFwiKTtcbnZhciBfaGVhZE1hbmFnZXIgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyXCIpKTtcbnZhciBfcGFnZUxvYWRlciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi9wYWdlLWxvYWRlclwiKSk7XG52YXIgX3BlcmZvcm1hbmNlUmVsYXllciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi9wZXJmb3JtYW5jZS1yZWxheWVyXCIpKTtcbnZhciBfcm91dGVBbm5vdW5jZXIgPSByZXF1aXJlKFwiLi9yb3V0ZS1hbm5vdW5jZXJcIik7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuL3JvdXRlclwiKTtcbnZhciBfaXNFcnJvciA9IHJlcXVpcmUoXCIuLi9saWIvaXMtZXJyb3JcIik7XG52YXIgX2ltYWdlQ29uZmlnQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xudmFyIF9yZW1vdmVCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL3JlbW92ZS1iYXNlLXBhdGhcIik7XG52YXIgX2hhc0Jhc2VQYXRoID0gcmVxdWlyZShcIi4vaGFzLWJhc2UtcGF0aFwiKTtcbmNvbnN0IFJlYWN0RE9NID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JFQUNUX1JPT1QgPyByZXF1aXJlKCdyZWFjdC1kb20vY2xpZW50JykgOiByZXF1aXJlKCdyZWFjdC1kb20nKTtcbmNvbnN0IHZlcnNpb24gPSBcIjEyLjMuMlwiO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmxldCByb3V0ZXI7XG5leHBvcnRzLnJvdXRlciA9IHJvdXRlcjtcbmNvbnN0IGVtaXR0ZXIgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcbmV4cG9ydHMuZW1pdHRlciA9IGVtaXR0ZXI7XG5jb25zdCBsb29zZVRvQXJyYXkgPSAoaW5wdXQpPT5bXS5zbGljZS5jYWxsKGlucHV0KTtcbmxldCBpbml0aWFsRGF0YTtcbmxldCBkZWZhdWx0TG9jYWxlID0gdW5kZWZpbmVkO1xubGV0IGFzUGF0aDtcbmxldCBwYWdlTG9hZGVyO1xubGV0IGFwcEVsZW1lbnQ7XG5sZXQgaGVhZE1hbmFnZXI7XG5sZXQgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlID0gZmFsc2U7XG5sZXQgbGFzdEFwcFByb3BzO1xubGV0IGxhc3RSZW5kZXJSZWplY3Q7XG5sZXQgd2VicGFja0hNUjtcbmxldCBDYWNoZWRBcHAsIG9uUGVyZkVudHJ5O1xubGV0IENhY2hlZENvbXBvbmVudDtcbnNlbGYuX19uZXh0X3JlcXVpcmVfXyA9IF9fd2VicGFja19yZXF1aXJlX187XG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIGNvbXBvbmVudERpZENhdGNoKGNvbXBvbmVudEVyciwgaW5mbykge1xuICAgICAgICB0aGlzLnByb3BzLmZuKGNvbXBvbmVudEVyciwgaW5mbyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaCgpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlcGxhY2UgdGhlIHJvdXRlciBzdGF0ZSBpZjpcbiAgICAgICAgLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuICAgICAgICAvLyAtIGl0IHdhcyBhdXRvIGV4cG9ydGVkIGFuZCBpcyBhIGR5bmFtaWMgcm91dGUgKHRvIHByb3ZpZGUgcGFyYW1zKVxuICAgICAgICAvLyAtIGlmIGl0IGlzIGEgY2xpZW50LXNpZGUgc2tlbGV0b24gKGZhbGxiYWNrIHJlbmRlcilcbiAgICAgICAgLy8gLSBpZiBtaWRkbGV3YXJlIG1hdGNoZXMgdGhlIGN1cnJlbnQgcGFnZSAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgICAgIC8vIC0gaWYgcmV3cml0ZXMgaW4gbmV4dC5jb25maWcuanMgbWF0Y2ggKG1heSBoYXZlIHJld3JpdGUgcGFyYW1zKVxuICAgICAgICBpZiAocm91dGVyLmlzU3NyICYmIC8vIFdlIGRvbid0IHVwZGF0ZSBmb3IgNDA0IHJlcXVlc3RzIGFzIHRoaXMgY2FuIG1vZGlmeVxuICAgICAgICAvLyB0aGUgYXNQYXRoIHVuZXhwZWN0ZWRseSBlLmcuIGFkZGluZyBiYXNlUGF0aCB3aGVuXG4gICAgICAgIC8vIGl0IHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnRcbiAgICAgICAgaW5pdGlhbERhdGEucGFnZSAhPT0gJy80MDQnICYmIGluaXRpYWxEYXRhLnBhZ2UgIT09ICcvX2Vycm9yJyAmJiAoaW5pdGlhbERhdGEuaXNGYWxsYmFjayB8fCBpbml0aWFsRGF0YS5uZXh0RXhwb3J0ICYmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGVyLnBhdGhuYW1lKSB8fCBsb2NhdGlvbi5zZWFyY2ggfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyB8fCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpIHx8IGluaXRpYWxEYXRhLnByb3BzICYmIGluaXRpYWxEYXRhLnByb3BzLl9fTl9TU0cgJiYgKGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkpKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcXVlcnkgb24gbW91bnQgZm9yIGV4cG9ydGVkIHBhZ2VzXG4gICAgICAgICAgICByb3V0ZXIucmVwbGFjZShyb3V0ZXIucGF0aG5hbWUgKyAnPycgKyBTdHJpbmcoKDAsIF9xdWVyeXN0cmluZykuYXNzaWduKCgwLCBfcXVlcnlzdHJpbmcpLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocm91dGVyLnF1ZXJ5KSwgbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpKSksIGFzUGF0aCwge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyBJdCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICAgICAgICAgIF9oOiAxLFxuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHBhZ2VzIG11c3QgdHJpZ2dlciB0aGUgZGF0YSBmZXRjaCwgc28gdGhlIHRyYW5zaXRpb24gaXNcbiAgICAgICAgICAgICAgICAvLyBub3Qgc2hhbGxvdy5cbiAgICAgICAgICAgICAgICAvLyBPdGhlciBwYWdlcyAoc3RyaWN0bHkgdXBkYXRpbmcgcXVlcnkpIGhhcHBlbnMgc2hhbGxvd2x5LCBhcyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnRzIHdvdWxkIGFscmVhZHkgYmUgcHJlc2VudC5cbiAgICAgICAgICAgICAgICBzaGFsbG93OiAhaW5pdGlhbERhdGEuaXNGYWxsYmFjayAmJiAhaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZXJyLmNhbmNlbGxlZCkgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaCgpO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goKSB7XG4gICAgICAgIGxldCB7IGhhc2ggIH0gPSBsb2NhdGlvbjtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiYgaGFzaC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIC8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4gICAgICAgIC8vIGl0IHdvbid0IHNjcm9sbCBwcm9wZXJseS5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+ZWwuc2Nyb2xsSW50b1ZpZXcoKSwgMCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBSZWFjdERldk92ZXJsYXkgLCAgfSA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdERldk92ZXJsYXksIG51bGwsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICByZXR1cm4gX2luaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9pbml0aWFsaXplKCkge1xuICAgIF9pbml0aWFsaXplID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioob3B0cyA9IHt9KSB7XG4gICAgICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGlzIHNwZWNpZmljIGxpbmVzIGFyZSByZW1vdmVkIGluIHByb2R1Y3Rpb25cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICB3ZWJwYWNrSE1SID0gb3B0cy53ZWJwYWNrSE1SO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxEYXRhID0gSlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpLnRleHRDb250ZW50KTtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9EQVRBX18gPSBpbml0aWFsRGF0YTtcbiAgICAgICAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGluaXRpYWxEYXRhLmFzc2V0UHJlZml4IHx8ICcnO1xuICAgICAgICAvLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4gICAgICAgIC8vIFNvLCB0aGlzIGlzIGhvdyB3ZSBkbyBpdCBpbiB0aGUgY2xpZW50IHNpZGUgYXQgcnVudGltZVxuICAgICAgICBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyA9IGAke3ByZWZpeH0vX25leHQvYCAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgO1xuICAgICAgICAvLyBJbml0aWFsaXplIG5leHQvY29uZmlnIHdpdGggdGhlIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgKDAsIF9ydW50aW1lQ29uZmlnKS5zZXRDb25maWcoe1xuICAgICAgICAgICAgc2VydmVyUnVudGltZUNvbmZpZzoge30sXG4gICAgICAgICAgICBwdWJsaWNSdW50aW1lQ29uZmlnOiBpbml0aWFsRGF0YS5ydW50aW1lQ29uZmlnIHx8IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBhc1BhdGggPSAoMCwgX3V0aWxzKS5nZXRVUkwoKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIG5vdCB0byBhdHRlbXB0IHN0cmlwcGluZyBiYXNlUGF0aCBmb3IgNDA0c1xuICAgICAgICBpZiAoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgoYXNQYXRoKSkge1xuICAgICAgICAgICAgYXNQYXRoID0gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXNQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgY29uc3QgeyBub3JtYWxpemVMb2NhbGVQYXRoICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpO1xuICAgICAgICAgICAgY29uc3QgeyBkZXRlY3REb21haW5Mb2NhbGUgIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFyc2VSZWxhdGl2ZVVybCAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCcpO1xuICAgICAgICAgICAgY29uc3QgeyBmb3JtYXRVcmwgIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJyk7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbERhdGEubG9jYWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCBpbml0aWFsRGF0YS5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aCA9IGZvcm1hdFVybChwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVyaXZlIHRoZSBkZWZhdWx0IGxvY2FsZSBpZiBpdCB3YXNuJ3QgZGV0ZWN0ZWQgaW4gdGhlIGFzUGF0aFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBwcmVyZW5kZXIgc3RhdGljIHBhZ2VzIHdpdGggYWxsIHBvc3NpYmxlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jYWxlc1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlID0gaW5pdGlhbERhdGEubG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IGRldGVjdGluZyBkZWZhdWx0IGxvY2FsZSBiYXNlZCBvbiBob3N0bmFtZVxuICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX0RPTUFJTlMsIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgaWYgZGVmYXVsdExvY2FsZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyBoeWRyYXRpb24gdG8gcHJldmVudCBtaXNtYXRjaGVkIHJlbmRlcnNcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWREb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZSA9IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsRGF0YS5zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5pdFNjcmlwdExvYWRlciAgfSA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG4gICAgICAgICAgICBpbml0U2NyaXB0TG9hZGVyKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcGFnZUxvYWRlciA9IG5ldyBfcGFnZUxvYWRlci5kZWZhdWx0KGluaXRpYWxEYXRhLmJ1aWxkSWQsIHByZWZpeCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyID0gKFtyLCBmXSk9PnBhZ2VMb2FkZXIucm91dGVMb2FkZXIub25FbnRyeXBvaW50KHIsIGYpO1xuICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9QKSB7XG4gICAgICAgICAgICAvLyBEZWZlciBwYWdlIHJlZ2lzdHJhdGlvbiBmb3IgYW5vdGhlciB0aWNrLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGxcbiAgICAgICAgICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9QLm1hcCgocCk9PnNldFRpbWVvdXQoKCk9PnJlZ2lzdGVyKHApLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93Ll9fTkVYVF9QID0gW107XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoID0gcmVnaXN0ZXI7XG4gICAgICAgIGhlYWRNYW5hZ2VyID0gKDAsIF9oZWFkTWFuYWdlcikuZGVmYXVsdCgpO1xuICAgICAgICBoZWFkTWFuYWdlci5nZXRJc1NzciA9ICgpPT57XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmlzU3NyO1xuICAgICAgICB9O1xuICAgICAgICBhcHBFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fbmV4dCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXNzZXRQcmVmaXg6IHByZWZpeFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBfaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcCwgT2JqZWN0LmFzc2lnbih7fSwgYXBwUHJvcHMpKTtcbn1cbmZ1bmN0aW9uIEFwcENvbnRhaW5lcih7IGNoaWxkcmVuICB9KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb250YWluZXIsIHtcbiAgICAgICAgZm46IChlcnJvcik9Pi8vIFRPRE86IEZpeCBkaXNhYmxlZCBlc2xpbnQgcnVsZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgcmVuZGVyRXJyb3Ioe1xuICAgICAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3JcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT5jb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgcGFnZTogJywgZXJyKSlcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JvdXRlckNvbnRleHQuUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogKDAsIF9yb3V0ZXIpLm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkTWFuYWdlckNvbnRleHQuSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBoZWFkTWFuYWdlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaW1hZ2VDb25maWdDb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFNcbiAgICB9LCBjaGlsZHJlbikpKSk7XG59XG5jb25zdCB3cmFwQXBwID0gKEFwcCk9Pih3cmFwcGVkQXBwUHJvcHMpPT57XG4gICAgICAgIGNvbnN0IGFwcFByb3BzID0gX2V4dGVuZHMoe30sIHdyYXBwZWRBcHBQcm9wcywge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBlcnI6IGluaXRpYWxEYXRhLmVycixcbiAgICAgICAgICAgIHJvdXRlclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHBDb250YWluZXIsIG51bGwsIHJlbmRlckFwcChBcHAsIGFwcFByb3BzKSk7XG4gICAgfTtcbi8vIFRoaXMgbWV0aG9kIGhhbmRsZXMgYWxsIHJ1bnRpbWUgYW5kIGRlYnVnIGVycm9ycy5cbi8vIDQwNCBhbmQgNTAwIGVycm9ycyBhcmUgc3BlY2lhbCBraW5kIG9mIGVycm9yc1xuLy8gYW5kIHRoZXkgYXJlIHN0aWxsIGhhbmRsZSB2aWEgdGhlIG1haW4gcmVuZGVyIG1ldGhvZC5cbmZ1bmN0aW9uIHJlbmRlckVycm9yKHJlbmRlckVycm9yUHJvcHMpIHtcbiAgICBsZXQgeyBBcHAgLCBlcnIgIH0gPSByZW5kZXJFcnJvclByb3BzO1xuICAgIC8vIEluIGRldmVsb3BtZW50IHJ1bnRpbWUgZXJyb3JzIGFyZSBjYXVnaHQgYnkgb3VyIG92ZXJsYXlcbiAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIEEgTmV4dC5qcyByZW5kZXJpbmcgcnVudGltZSBlcnJvciBpcyBhbHdheXMgdW5yZWNvdmVyYWJsZVxuICAgICAgICAvLyBGSVhNRTogbGV0J3MgbWFrZSB0aGlzIHJlY292ZXJhYmxlIChlcnJvciBpbiBHSVAgY2xpZW50LXRyYW5zaXRpb24pXG4gICAgICAgIHdlYnBhY2tITVIub25VbnJlY292ZXJhYmxlRXJyb3IoKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbiAgICAgICAgLy8gcmVuZGVyIGl0c2VsZi5cbiAgICAgICAgLy8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIGRvUmVuZGVyKHtcbiAgICAgICAgICAgIEFwcDogKCk9Pm51bGwsXG4gICAgICAgICAgICBwcm9wczoge30sXG4gICAgICAgICAgICBDb21wb25lbnQ6ICgpPT5udWxsLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBjb25zb2xlLmVycm9yKGBBIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQsIHNlZSBoZXJlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2NsaWVudC1zaWRlLWV4Y2VwdGlvbi1vY2N1cnJlZGApO1xuICAgIHJldHVybiBwYWdlTG9hZGVyLmxvYWRQYWdlKCcvX2Vycm9yJykudGhlbigoeyBwYWdlOiBFcnJvckNvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9KT0+e1xuICAgICAgICByZXR1cm4gKGxhc3RBcHBQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogbGFzdEFwcFByb3BzLkNvbXBvbmVudCkgPT09IEVycm9yQ29tcG9uZW50ID8gaW1wb3J0KCcuLi9wYWdlcy9fZXJyb3InKS50aGVuKChlcnJvck1vZHVsZSk9PntcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnQoJy4uL3BhZ2VzL19hcHAnKS50aGVuKChhcHBNb2R1bGUpPT57XG4gICAgICAgICAgICAgICAgQXBwID0gYXBwTW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgcmVuZGVyRXJyb3JQcm9wcy5BcHAgPSBBcHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yTW9kdWxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oKG0pPT4oe1xuICAgICAgICAgICAgICAgIEVycm9yQ29tcG9uZW50OiBtLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgICAgICB9KSkgOiB7XG4gICAgICAgICAgICBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzXG4gICAgICAgIH07XG4gICAgfSkudGhlbigoeyBFcnJvckNvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9KT0+e1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGRvIGEgbm9ybWFsIHJlbmRlciB3aXRoIHRoZSBgRXJyb3JDb21wb25lbnRgIGFzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUgdXBvbiBpbml0aWFsIHJlbmRlciwgd2UgY2FuIHVzZSB0aGUgcHJvcHMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0SW5pdGlhbFByb3BzYCBvbiBgQXBwYCBiZWZvcmUgbW91bnRpbmcuXG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB3cmFwQXBwKEFwcCk7XG4gICAgICAgIGNvbnN0IGFwcEN0eCA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgcm91dGVyLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbml0aWFsRGF0YS5wYWdlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBpbml0aWFsRGF0YS5xdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgICAgICAgQXBwVHJlZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCgocmVmID0gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5lcnIpID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcyA6ICgwLCBfdXRpbHMpLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCBhcHBDdHgpKS50aGVuKChpbml0UHJvcHMpPT4vLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgIGRvUmVuZGVyKF9leHRlbmRzKHt9LCByZW5kZXJFcnJvclByb3BzLCB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRQcm9wc1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9KTtcbn1cbi8vIER1bW15IGNvbXBvbmVudCB0aGF0IHdlIHJlbmRlciBhcyBhIGNoaWxkIG9mIFJvb3Qgc28gdGhhdCB3ZSBjYW5cbi8vIHRvZ2dsZSB0aGUgY29ycmVjdCBzdHlsZXMgYmVmb3JlIHRoZSBwYWdlIGlzIHJlbmRlcmVkLlxuZnVuY3Rpb24gSGVhZCh7IGNhbGxiYWNrICB9KSB7XG4gICAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWRcbiAgICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZS5cbiAgICBfcmVhY3QuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3QoKCk9PmNhbGxiYWNrKCksIFtcbiAgICAgICAgY2FsbGJhY2tcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmxldCByZWFjdFJvb3QgPSBudWxsO1xuLy8gT24gaW5pdGlhbCByZW5kZXIgYSBoeWRyYXRlIHNob3VsZCBhbHdheXMgaGFwcGVuXG5sZXQgc2hvdWxkSHlkcmF0ZSA9IHRydWU7XG5mdW5jdGlvbiBjbGVhck1hcmtzKCkge1xuICAgIFtcbiAgICAgICAgJ2JlZm9yZVJlbmRlcicsXG4gICAgICAgICdhZnRlckh5ZHJhdGUnLFxuICAgICAgICAnYWZ0ZXJSZW5kZXInLFxuICAgICAgICAncm91dGVDaGFuZ2UnXG4gICAgXS5mb3JFYWNoKChtYXJrKT0+cGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKSk7XG59XG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyaygnYWZ0ZXJIeWRyYXRlJykgLy8gbWFyayBlbmQgb2YgaHlkcmF0aW9uXG4gICAgO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtYmVmb3JlLWh5ZHJhdGlvbicsICduYXZpZ2F0aW9uU3RhcnQnLCAnYmVmb3JlUmVuZGVyJyk7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVySHlkcmF0ZScpO1xuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdOZXh0LmpzLWh5ZHJhdGlvbicpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKSB7XG4gICAgaWYgKCFfdXRpbHMuU1QpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKCdhZnRlclJlbmRlcicpIC8vIG1hcmsgZW5kIG9mIHJlbmRlclxuICAgIDtcbiAgICBjb25zdCBuYXZTdGFydEVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdyb3V0ZUNoYW5nZScsICdtYXJrJyk7XG4gICAgaWYgKCFuYXZTdGFydEVudHJpZXMubGVuZ3RoKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJywgbmF2U3RhcnRFbnRyaWVzWzBdLm5hbWUsICdiZWZvcmVSZW5kZXInKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJlbmRlcicsICdiZWZvcmVSZW5kZXInLCAnYWZ0ZXJSZW5kZXInKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yZW5kZXInKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbiAgICBbXG4gICAgICAgICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLFxuICAgICAgICAnTmV4dC5qcy1yZW5kZXInXG4gICAgXS5mb3JFYWNoKChtZWFzdXJlKT0+cGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlKSk7XG59XG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoZG9tRWwsIGZuKSB7XG4gICAgLy8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnYmVmb3JlUmVuZGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0RWwgPSBmbihzaG91bGRIeWRyYXRlID8gbWFya0h5ZHJhdGVDb21wbGV0ZSA6IG1hcmtSZW5kZXJDb21wbGV0ZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ST09UKSB7XG4gICAgICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICAgICAgICAvLyBVbmxpa2Ugd2l0aCBjcmVhdGVSb290LCB5b3UgZG9uJ3QgbmVlZCBhIHNlcGFyYXRlIHJvb3QucmVuZGVyKCkgY2FsbCBoZXJlXG4gICAgICAgICAgICByZWFjdFJvb3QgPSBSZWFjdERPTS5oeWRyYXRlUm9vdChkb21FbCwgcmVhY3RFbCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRyYW5zaXRpb24gPSBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb247XG4gICAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICByZWFjdFJvb3QucmVuZGVyKHJlYWN0RWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgY2hlY2sgZm9yIGAuaHlkcmF0ZWAgaXMgdGhlcmUgdG8gc3VwcG9ydCBSZWFjdCBhbHRlcm5hdGl2ZXMgbGlrZSBwcmVhY3RcbiAgICAgICAgaWYgKHNob3VsZEh5ZHJhdGUpIHtcbiAgICAgICAgICAgIFJlYWN0RE9NLmh5ZHJhdGUocmVhY3RFbCwgZG9tRWwpO1xuICAgICAgICAgICAgc2hvdWxkSHlkcmF0ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RET00ucmVuZGVyKHJlYWN0RWwsIGRvbUVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIFJvb3QoeyBjYWxsYmFja3MgLCBjaGlsZHJlbiAgfSkge1xuICAgIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWRcbiAgICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZVxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKT0+Y2FsbGJhY2soKSksIFtcbiAgICAgICAgY2FsbGJhY2tzXG4gICAgXSk7XG4gICAgLy8gV2Ugc2hvdWxkIGFzayB0byBtZWFzdXJlIHRoZSBXZWIgVml0YWxzIGFmdGVyIHJlbmRlcmluZyBjb21wbGV0ZXMgc28gd2VcbiAgICAvLyBkb24ndCBjYXVzZSBhbnkgaHlkcmF0aW9uIGRlbGF5OlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAoMCwgX3BlcmZvcm1hbmNlUmVsYXllcikuZGVmYXVsdChvblBlcmZFbnRyeSk7XG4gICAgfSwgW10pO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gZG9SZW5kZXIoaW5wdXQpIHtcbiAgICBsZXQgeyBBcHAgLCBDb21wb25lbnQgLCBwcm9wcyAsIGVyciAgfSA9IGlucHV0O1xuICAgIGxldCBzdHlsZVNoZWV0cyA9ICdpbml0aWFsJyBpbiBpbnB1dCA/IHVuZGVmaW5lZCA6IGlucHV0LnN0eWxlU2hlZXRzO1xuICAgIENvbXBvbmVudCA9IENvbXBvbmVudCB8fCBsYXN0QXBwUHJvcHMuQ29tcG9uZW50O1xuICAgIHByb3BzID0gcHJvcHMgfHwgbGFzdEFwcFByb3BzLnByb3BzO1xuICAgIGNvbnN0IGFwcFByb3BzID0gX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZXJyLFxuICAgICAgICByb3V0ZXJcbiAgICB9KTtcbiAgICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICAgIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlUHJvbWlzZSA9ICgpPT57XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFJlbmRlclJlamVjdCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDYW5jZWwgcmVuZGVyaW5nIHJvdXRlJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBhIHJldHVybiB0eXBlIHRvIGVuc3VyZSBpdCBkb2Vzbid0IHN0YXJ0IHJldHVybmluZyBhXG4gICAgLy8gUHJvbWlzZS4gSXQgc2hvdWxkIHJlbWFpbiBzeW5jaHJvbm91cy5cbiAgICBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICBpZiAoIXN0eWxlU2hlZXRzIHx8IC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3MgPSBsb29zZVRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJykpO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBuZXcgU2V0KGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpKSk7XG4gICAgICAgIGNvbnN0IG5vc2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignbm9zY3JpcHRbZGF0YS1uLWNzc10nKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBub3NjcmlwdCA9PSBudWxsID8gdm9pZCAwIDogbm9zY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLW4tY3NzJyk7XG4gICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiAsIHRleHQgIH0pPT57XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRIcmVmcy5oYXMoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicsIGhyZWYpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpO1xuICAgICAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25IZWFkQ29tbWl0KCkge1xuICAgICAgICBpZiAoLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIC8vIFdlIGNhbiBza2lwIHRoaXMgZHVyaW5nIGh5ZHJhdGlvbi4gUnVubmluZyBpdCB3b250IGNhdXNlIGFueSBoYXJtLCBidXRcbiAgICAgICAgLy8gd2UgbWF5IGFzIHdlbGwgc2F2ZSB0aGUgQ1BVIGN5Y2xlczpcbiAgICAgICAgc3R5bGVTaGVldHMgJiYgLy8gRW5zdXJlIHRoaXMgcmVuZGVyIHdhcyBub3QgY2FuY2VsZWRcbiAgICAgICAgIWNhbmNlbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNpcmVkSHJlZnMgPSBuZXcgU2V0KHN0eWxlU2hlZXRzLm1hcCgocyk9PnMuaHJlZikpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBjdXJyZW50U3R5bGVUYWdzLm1hcCgodGFnKT0+dGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnKSk7XG4gICAgICAgICAgICAvLyBUb2dnbGUgYDxzdHlsZT5gIHRhZ3Mgb24gb3Igb2ZmIGRlcGVuZGluZyBvbiBpZiB0aGV5J3JlIG5lZWRlZDpcbiAgICAgICAgICAgIGZvcihsZXQgaWR4ID0gMDsgaWR4IDwgY3VycmVudEhyZWZzLmxlbmd0aDsgKytpZHgpe1xuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkSHJlZnMuaGFzKGN1cnJlbnRIcmVmc1tpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGVUYWdzW2lkeF0ucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW9yZGVyIHN0eWxlcyBpbnRvIGludGVuZGVkIG9yZGVyOlxuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdub3NjcmlwdFtkYXRhLW4tY3NzXScpO1xuICAgICAgICAgICAgaWYgKC8vIFRoaXMgc2hvdWxkIGJlIGFuIGludmFyaWFudDpcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYgIH0pPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtbi1ocmVmPVwiJHtocmVmfVwiXWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFyZ2V0VGFnLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSB0YXJnZXRUYWc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGNsZWFuIHVwIHNlcnZlciByZW5kZXJlZCBzdHlsZXNoZWV0czpcbiAgICAgICAgICAgIGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2RhdGEtbi1wXScpKS5mb3JFYWNoKChlbCk9PntcbiAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5zY3JvbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gJ2F1dG8nO1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKGlucHV0LnNjcm9sbC54LCBpbnB1dC5zY3JvbGwueSk7XG4gICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IGV4aXN0aW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpIHtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UoKTtcbiAgICB9XG4gICAgb25TdGFydCgpO1xuICAgIGNvbnN0IGVsZW0gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIZWFkLCB7XG4gICAgICAgIGNhbGxiYWNrOiBvbkhlYWRDb21taXRcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lciwgbnVsbCwgcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3BvcnRhbC5Qb3J0YWwsIHtcbiAgICAgICAgdHlwZTogXCJuZXh0LXJvdXRlLWFubm91bmNlclwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZUFubm91bmNlci5Sb3V0ZUFubm91bmNlciwgbnVsbCkpKSk7XG4gICAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQsIChjYWxsYmFjayk9Pi8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvblJvb3RDb21taXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN0cmljdE1vZGUsIG51bGwsIGVsZW0pIDogZWxlbSkpO1xuICAgIHJldHVybiByZW5kZXJQcm9taXNlO1xufVxuZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgX3JlbmRlciA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgICAgIGlmIChyZW5kZXJpbmdQcm9wcy5lcnIpIHtcbiAgICAgICAgICAgIHlpZWxkIHJlbmRlckVycm9yKHJlbmRlcmluZ1Byb3BzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgeWllbGQgZG9SZW5kZXIocmVuZGVyaW5nUHJvcHMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlckVyciA9ICgwLCBfaXNFcnJvcikuZ2V0UHJvcGVyRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIGlmIChyZW5kZXJFcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVuZGVyRXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZW5kZXJFcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCByZW5kZXJFcnJvcihfZXh0ZW5kcyh7fSwgcmVuZGVyaW5nUHJvcHMsIHtcbiAgICAgICAgICAgICAgICBlcnI6IHJlbmRlckVyclxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGUob3B0cykge1xuICAgIHJldHVybiBfaHlkcmF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2h5ZHJhdGUoKSB7XG4gICAgX2h5ZHJhdGUgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKihvcHRzKSB7XG4gICAgICAgIGxldCBpbml0aWFsRXJyID0gaW5pdGlhbERhdGEuZXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXBwRW50cnlwb2ludCA9IHlpZWxkIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoJy9fYXBwJyk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBhcHBFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXBwRW50cnlwb2ludC5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29tcG9uZW50OiBhcHAgLCBleHBvcnRzOiBtb2QgIH0gPSBhcHBFbnRyeXBvaW50O1xuICAgICAgICAgICAgQ2FjaGVkQXBwID0gYXBwO1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QucmVwb3J0V2ViVml0YWxzKSB7XG4gICAgICAgICAgICAgICAgb25QZXJmRW50cnkgPSAoeyBpZCAsIG5hbWUgLCBzdGFydFRpbWUgLCB2YWx1ZSAsIGR1cmF0aW9uICwgZW50cnlUeXBlICwgZW50cmllcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUlEID0gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoOWUxMiAtIDEpKSArIDFlMTJ9YDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlcmZTdGFydEVudHJ5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcyAmJiBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyZlN0YXJ0RW50cnkgPSBlbnRyaWVzWzBdLnN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ZWJWaXRhbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQgfHwgdW5pcXVlSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUgfHwgcGVyZlN0YXJ0RW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT0gbnVsbCA/IGR1cmF0aW9uIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZW50cnlUeXBlID09PSAnbWFyaycgfHwgZW50cnlUeXBlID09PSAnbWVhc3VyZScgPyAnY3VzdG9tJyA6ICd3ZWItdml0YWwnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG1vZC5yZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFnZUVudHJ5cG9pbnQgPSAvLyBUaGUgZGV2IHNlcnZlciBmYWlscyB0byBzZXJ2ZSBzY3JpcHQgYXNzZXRzIHdoZW4gdGhlcmUncyBhIGh5ZHJhdGlvblxuICAgICAgICAgICAgLy8gZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgZW50cnlwb2ludC5cbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGluaXRpYWxEYXRhLmVyciA/IHtcbiAgICAgICAgICAgICAgICBlcnJvcjogaW5pdGlhbERhdGEuZXJyXG4gICAgICAgICAgICB9IDogeWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChpbml0aWFsRGF0YS5wYWdlKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcGFnZUVudHJ5cG9pbnQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ2FjaGVkQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke2luaXRpYWxEYXRhLnBhZ2V9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICAgICAgICAgIGluaXRpYWxFcnIgPSAoMCwgX2lzRXJyb3IpLmdldFByb3BlckVycm9yKGVycm9yMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCB7IGdldFNlcnZlckVycm9yICwgIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvZGlzdC9jbGllbnQnKTtcbiAgICAgICAgICAgIC8vIFNlcnZlci1zaWRlIHJ1bnRpbWUgZXJyb3JzIG5lZWQgdG8gYmUgcmUtdGhyb3duIG9uIHRoZSBjbGllbnQtc2lkZSBzb1xuICAgICAgICAgICAgLy8gdGhhdCB0aGUgb3ZlcmxheSBpcyByZW5kZXJlZC5cbiAgICAgICAgICAgIGlmIChpbml0aWFsRXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxFcnIgPT09IGluaXRpYWxEYXRhLmVycikge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGVycm9yIG9iamVjdC4gV2UgYHRocm93YCBpdCBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHNldCB0aGUgYHN0YWNrYCB3aGVuIHRocm93biwgYW5kIHdlIHdhbnQgdG8gZW5zdXJlIG91cnMgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3Qgb3ZlcnJpZGRlbiB3aGVuIHdlIHJlLXRocm93IGl0IGJlbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbml0aWFsRXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGluaXRpYWxFcnIuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBnZXRTZXJ2ZXJFcnJvcihlcnJvciwgaW5pdGlhbEVyci5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKSB7XG4gICAgICAgICAgICB5aWVsZCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShpbml0aWFsRGF0YS5keW5hbWljSWRzKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLnJvdXRlciA9IHJvdXRlciA9ICgwLCBfcm91dGVyKS5jcmVhdGVSb3V0ZXIoaW5pdGlhbERhdGEucGFnZSwgaW5pdGlhbERhdGEucXVlcnksIGFzUGF0aCwge1xuICAgICAgICAgICAgaW5pdGlhbFByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICAgICAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgICAgICAgICAgd3JhcEFwcCxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbEVycixcbiAgICAgICAgICAgIGlzRmFsbGJhY2s6IEJvb2xlYW4oaW5pdGlhbERhdGEuaXNGYWxsYmFjayksXG4gICAgICAgICAgICBzdWJzY3JpcHRpb246IChpbmZvLCBBcHAsIHNjcm9sbCk9PnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCBpbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgIEFwcCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgbG9jYWxlOiBpbml0aWFsRGF0YS5sb2NhbGUsXG4gICAgICAgICAgICBsb2NhbGVzOiBpbml0aWFsRGF0YS5sb2NhbGVzLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIGRvbWFpbkxvY2FsZXM6IGluaXRpYWxEYXRhLmRvbWFpbkxvY2FsZXMsXG4gICAgICAgICAgICBpc1ByZXZpZXc6IGluaXRpYWxEYXRhLmlzUHJldmlld1xuICAgICAgICB9KTtcbiAgICAgICAgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlID0geWllbGQgcm91dGVyLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlO1xuICAgICAgICBjb25zdCByZW5kZXJDdHggPSB7XG4gICAgICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIHByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbEVyclxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgICAgIHlpZWxkIG9wdHMuYmVmb3JlUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKHJlbmRlckN0eCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9oeWRyYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXRpYWxpemUiLCJoeWRyYXRlIiwiZW1pdHRlciIsInJvdXRlciIsInZlcnNpb24iLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfZXh0ZW5kcyIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVhY3QiLCJfaGVhZE1hbmFnZXJDb250ZXh0IiwiX21pdHQiLCJfcm91dGVyQ29udGV4dCIsIl9pc0R5bmFtaWMiLCJfcXVlcnlzdHJpbmciLCJfcnVudGltZUNvbmZpZyIsIl91dGlscyIsIl9wb3J0YWwiLCJfaGVhZE1hbmFnZXIiLCJfcGFnZUxvYWRlciIsIl9wZXJmb3JtYW5jZVJlbGF5ZXIiLCJfcm91dGVBbm5vdW5jZXIiLCJfcm91dGVyIiwiX2lzRXJyb3IiLCJfaW1hZ2VDb25maWdDb250ZXh0IiwiX3JlbW92ZUJhc2VQYXRoIiwiX2hhc0Jhc2VQYXRoIiwiUmVhY3RET00iLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JFQUNUX1JPT1QiLCJsb29zZVRvQXJyYXkiLCJpbnB1dCIsInNsaWNlIiwiY2FsbCIsImluaXRpYWxEYXRhIiwiZGVmYXVsdExvY2FsZSIsInVuZGVmaW5lZCIsImFzUGF0aCIsInBhZ2VMb2FkZXIiLCJhcHBFbGVtZW50IiwiaGVhZE1hbmFnZXIiLCJpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUiLCJsYXN0QXBwUHJvcHMiLCJsYXN0UmVuZGVyUmVqZWN0Iiwid2VicGFja0hNUiIsIkNhY2hlZEFwcCIsIm9uUGVyZkVudHJ5IiwiQ2FjaGVkQ29tcG9uZW50Iiwic2VsZiIsIl9fbmV4dF9yZXF1aXJlX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiQ29udGFpbmVyIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJjb21wb25lbnRFcnIiLCJpbmZvIiwicHJvcHMiLCJmbiIsImNvbXBvbmVudERpZE1vdW50Iiwic2Nyb2xsVG9IYXNoIiwiaXNTc3IiLCJwYWdlIiwiaXNGYWxsYmFjayIsIm5leHRFeHBvcnQiLCJpc0R5bmFtaWNSb3V0ZSIsInBhdGhuYW1lIiwibG9jYXRpb24iLCJzZWFyY2giLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJfaCIsInNoYWxsb3ciLCJjYXRjaCIsImVyciIsImNhbmNlbGxlZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImhhc2giLCJzdWJzdHJpbmciLCJlbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJyZW5kZXIiLCJjaGlsZHJlbiIsIlJlYWN0RGV2T3ZlcmxheSIsImNyZWF0ZUVsZW1lbnQiLCJDb21wb25lbnQiLCJfaW5pdGlhbGl6ZSIsImFwcGx5IiwiYXJndW1lbnRzIiwib3B0cyIsInByZWZpeCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwYXJzZVJlbGF0aXZlVXJsIiwiZm9ybWF0VXJsIiwicGFyc2VkQXMiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGV0ZWN0ZWREb21haW4iLCJpbml0U2NyaXB0TG9hZGVyIiwicmVnaXN0ZXIiLCJKU09OIiwicGFyc2UiLCJ0ZXh0Q29udGVudCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJhc3NldFByZWZpeCIsIl9fd2VicGFja19wdWJsaWNfcGF0aF9fIiwic2V0Q29uZmlnIiwic2VydmVyUnVudGltZUNvbmZpZyIsInB1YmxpY1J1bnRpbWVDb25maWciLCJydW50aW1lQ29uZmlnIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJsb2NhbGVzIiwiZGV0ZWN0ZWRMb2NhbGUiLCJsb2NhbGUiLCJfX05FWFRfSTE4Tl9ET01BSU5TIiwiaG9zdG5hbWUiLCJzY3JpcHRMb2FkZXIiLCJidWlsZElkIiwiciIsImYiLCJyb3V0ZUxvYWRlciIsIm9uRW50cnlwb2ludCIsIl9fTkVYVF9QIiwibWFwIiwicCIsInB1c2giLCJnZXRJc1NzciIsInJlbmRlckFwcCIsIkFwcCIsImFwcFByb3BzIiwiQXBwQ29udGFpbmVyIiwiZXJyb3IiLCJyZW5kZXJFcnJvciIsImNvbnNvbGUiLCJSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJtYWtlUHVibGljUm91dGVySW5zdGFuY2UiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJfX05FWFRfSU1BR0VfT1BUUyIsIndyYXBBcHAiLCJ3cmFwcGVkQXBwUHJvcHMiLCJyZW5kZXJFcnJvclByb3BzIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJkb1JlbmRlciIsInN0eWxlU2hlZXRzIiwibG9hZFBhZ2UiLCJ0aGVuIiwiRXJyb3JDb21wb25lbnQiLCJlcnJvck1vZHVsZSIsImFwcE1vZHVsZSIsIm0iLCJyZWYiLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwiSGVhZCIsImNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwicmVhY3RSb290Iiwic2hvdWxkSHlkcmF0ZSIsImNsZWFyTWFya3MiLCJmb3JFYWNoIiwibWFyayIsInBlcmZvcm1hbmNlIiwibWFya0h5ZHJhdGVDb21wbGV0ZSIsIlNUIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJtYXJrUmVuZGVyQ29tcGxldGUiLCJuYXZTdGFydEVudHJpZXMiLCJsZW5ndGgiLCJuYW1lIiwiY2xlYXJNZWFzdXJlcyIsInJlbmRlclJlYWN0RWxlbWVudCIsImRvbUVsIiwicmVhY3RFbCIsImh5ZHJhdGVSb290Iiwic3RhcnRUcmFuc2l0aW9uIiwiUm9vdCIsImNhbGxiYWNrcyIsInVzZUVmZmVjdCIsIl9fTkVYVF9URVNUX01PREUiLCJfX05FWFRfSFlEUkFURUQiLCJfX05FWFRfSFlEUkFURURfQ0IiLCJvblN0YXJ0IiwiY3VycmVudFN0eWxlVGFncyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjdXJyZW50SHJlZnMiLCJTZXQiLCJ0YWciLCJnZXRBdHRyaWJ1dGUiLCJub3NjcmlwdCIsInF1ZXJ5U2VsZWN0b3IiLCJub25jZSIsImhyZWYiLCJ0ZXh0IiwiaGFzIiwic3R5bGVUYWciLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9uSGVhZENvbW1pdCIsImNhbmNlbGVkIiwiZGVzaXJlZEhyZWZzIiwicyIsImlkeCIsInJlbW92ZUF0dHJpYnV0ZSIsInJlZmVyZW5jZU5vZGUiLCJ0YXJnZXRUYWciLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwibmV4dFNpYmxpbmciLCJyZW1vdmVDaGlsZCIsInNjcm9sbCIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZXhpc3RpbmciLCJzdHlsZSIsInNjcm9sbEJlaGF2aW9yIiwic2Nyb2xsVG8iLCJ4IiwieSIsIm9uUm9vdENvbW1pdCIsInJlc29sdmVQcm9taXNlIiwicmVuZGVyUHJvbWlzZSIsInJlamVjdCIsIkVycm9yIiwiZWxlbSIsIkZyYWdtZW50IiwiUG9ydGFsIiwidHlwZSIsIlJvdXRlQW5ub3VuY2VyIiwiX19ORVhUX1NUUklDVF9NT0RFIiwiU3RyaWN0TW9kZSIsInJlbmRlcmluZ1Byb3BzIiwiX3JlbmRlciIsInJlbmRlckVyciIsImdldFByb3BlckVycm9yIiwiX2h5ZHJhdGUiLCJpbml0aWFsRXJyIiwiYXBwRW50cnlwb2ludCIsImFwcCIsIm1vZCIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZXJyb3IxIiwiZ2V0U2VydmVyRXJyb3IiLCJyZW5kZXJDdHgiLCJ3aGVuRW50cnlwb2ludCIsImNvbXBvbmVudCIsInJlcG9ydFdlYlZpdGFscyIsImlkIiwic3RhcnRUaW1lIiwiZHVyYXRpb24iLCJlbnRyeVR5cGUiLCJlbnRyaWVzIiwidW5pcXVlSUQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJ3ZWJWaXRhbHMiLCJsYWJlbCIsIm1lc3NhZ2UiLCJlIiwic3RhY2siLCJzb3VyY2UiLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiZHluYW1pY0lkcyIsImNyZWF0ZVJvdXRlciIsImluaXRpYWxQcm9wcyIsIkJvb2xlYW4iLCJzdWJzY3JpcHRpb24iLCJkb21haW5Mb2NhbGVzIiwiaXNQcmV2aWV3IiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJpbml0aWFsIiwiYmVmb3JlUmVuZGVyIiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n"));

/***/ })

});